# 《Effective Java》

## 《Effective Java 中文版第3版》

**书籍内容**：

- 创建和销毁对象
  - 第1条：考虑使用静态工厂方法替代构造方法
  - 第2条：当构造方法参数过多时使用 builder 模式
  - 第3条：使用私有构造方法或枚类实现 Singleton 属性
  - 第4条：使用私有构造方法执行非实例化
  - 第5条：依赖注入优于硬连接资源 (hardwiring resources)
  - 第6条：避免创建不必要的对象
  - 第7条：消除过期的对象引用
  - 第8条：避免使用 Finalizer 和 Cleaner 机制
  - 第9条：使用 try-with-resources 语句替代 try-finally 语句
- 对于所有对象都通用的方法
  - 第10条：重写 equals 方法时遵守通用约定
  - 第11条：重写 equals 方法时同时也要重写 hashcode 方法
  - 第12条：始终重写 toString 方法
  - 第13条：谨慎地重写 clone 方法
  - 第14条：考虑实现 Comparable 接口
- 类和接口
  - 第15条：使类和成员的可访问性最小化
  - 第16条：在公共类中使用访问方法而不是公共属性
  - 第17条：最小化可变性
  - 第18条：组合优于继承
  - 第19条：要么设计继承并提供文档说明，要么禁用继承
  - 第20条：接口优于抽象类
  - 第21条：为后代设计接口
  - 第22条：接口仅用来定义类型
  - 第23条：类层次结构优于标签类
  - 第24条：支持使用静态成员类而不是非静态类
  - 第25条：将源文件限制为单个顶级类
- 泛型
  - 第26条：不要使用原始类型
  - 第27条：消除非检查警告
  - 第28条：列表优于数组
  - 第29条：优先考虑泛型
  - 第30条：优先使用泛型方法
  - 第31条：使用限定通配符来增加 API 的灵活性
  - 第32条：合理地结合泛型和可变参数
  - 第33条：优先考虑类型安全的异构容器
- 枚举和注解
  - 第34条：使用 enum 替代 int 常量
  - 第35条：使用实例属性替代序数
  - 第36条：使用 EnumSet 替代位属性
  - 第37条：使用 EnumMap 替代序数索引
  - 第38条：使用接口模拟可扩展的枚举
  - 第39条：注解优于命名模式
  - 第40条：始终使用 Override 注解
  - 第41条：使用标记接口定义类型
- Lambdas and Streams
  - 第42条：lambda 表达式优于匿名类
  - 第43条：方法引用优于 lambda 表达式
  - 第44条：优先使用标准的函数式接口
  - 第45条：明智审慎地使用 Stream
  - 第46条：优先考虑流中无副作用的函数
  - 第47条：优先使用 Collection 而不是 Stream 来作为方法的返回类型
  - 第48条：谨慎使用流并行
- 方法
  - 第49条：检查参数有效性
  - 第50条：必要时进行防御性拷⻉
  - 第51条：仔细设计方法签名
  - 第52条：明智审慎地使用重载
  - 第53条：明智审慎地使用可变参数
  - 第54条：返回空的数组或集合，不要返回 null
  - 第55条：明智审慎地返回 Optional
  - 第56条：为所有已公开的 API 元素编写文档注释
- 通用程序设计
  - 第57条：最小化局部变量的作用域
  - 第58条：for-each 循环优于传统 for 循环
  - 第59条：了解并使用库
  - 第60条：若需要精确答案就应避免使用 float 和 double 类型
  - 第61条：基本数据类型优于包装类
  - 第62条：当使用其他类型更合适时应避免使用字符串
  - 第63条：当心字符串连接引起的性能问题
  - 第64条：通过接口引用对象
  - 第65条：接口优于反射
  - 第66条：明智审慎地本地方法
  - 第67条：明智审慎地进行优化
  - 第68条：遵守被广泛认可的命名约定
- 异常
  - 第69条：只针对异常的情况下才使用异常
  - 第70条：对可恢复的情况使用受检异常，对编程错误使用运行时异常
  - 第71条：避免不必要的使用受检异常
  - 第72条：优先使用标准的异常
  - 第73条：抛出与抽象对应的异常
  - 第74条：每个方法抛出的异常都需要创建文档
  - 第75条：在细节消息中包含失败一捕获信息
  - 第76条：保持失败原子性
  - 第77条：不要忽略异常
- 并发
  - 第78条：同步访问共享的可变数据
  - 第79条：避免过度同步
  - 第80条：executor、task 和 stream 优先于线程
  - 第81条：并发工具优于 wait 和 notify
  - 第82条：文档应包含线程安全属性
  - 第83条：明智审慎的使用延迟初始化
  - 第84条：不要依赖线程调度器
- 序列化
  - 第85条：优先选择 Java 序列化的替代方案
  - 第86条：非常谨慎地实现 Serializable
  - 第87条：考虑使用自定义的序列化形式
  - 第88条：保护性的编写 readObject 方法
  - 第89条：对于实例控制，枚举类型优于 readResolve
  - 第90条：考虑用序列化代理代替序列化实例

## 资源

中文翻译 Github 仓库地址：<https://github.com/sjsdfg/effective-java-3rd-chinese>

英文版阅读地址：<https://kea.nu/files/textbooks/new/Effective%20Java%20%282017%2C%20Addison-Wesley%29.pdf>

英文原版项目示例代码 Github 仓库地址：<https://github.com/jbloch/effective-java-3e-source-code>
